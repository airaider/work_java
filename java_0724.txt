Chapter 4 Class Design

구조적인 프로그램으로 Data를 여러 모듈들이 access하여 접근할 수 있다.
하지만 수정이 필요할시 전부를 고쳐야할 경우도 생긴다

객체지향은 유지보수에 탁월하다
각 프로그램의 구성 단위를 객체라고 부른다
객체지향
Association     has a
Dependency      use a
Generalization  is a
=(Inheretence)

객체(Object)
-객체 지향 program의 구성(재사용, 유지보수) 단위
-특성(Data)과 행위(Method)로 구성됨
-Interface(표준)이 일치하는 것들 끼리 연동 가능 
-Class

class는 무조건 동적이다 (class 앞에 static 사용 불가)

[public][final or abstact]
[modifiers] class class명{ (클래스 선언)
    
    //속성  abstract을 뺀 나머지
    [modifiers] 데이터타입  속성명_attribute(변수); 
    heap에 계속 존재한다(local은 스택에 올렸다가 method종료와 제거)


    //생성자
    [access_modifier] 클래스명([인자들])


    //method 선언
    [modifier] 리턴타입 메서드명([인자들...])
    return [값(리턴타입과 동일)] or void
 
} (클래스 종료)

access : public, protected, private, 생략
usage : static, final, abstract을

선언
클래스명 변수명;
생성
변수명 = new 생성자([값])
hashcode

속성접근    hashcode(변수명).속성명 :
함수호출    hashcode(변수명).method(~) : 

new 생성자(~).

Customer cust = new Customer("ssafy", 2, "강남구");     
                (0x73)
stack{
    Customer[
        name["ssafy"]
        age[2]
        address["강남구"]
        this[0x73]
    ]
    함수 콜 이후에는 날라간다


    main method 생성
    cust    [0x73]
    args[0x11]  //hashtable로 이동후에 hash값을 올려보고 값을 가져옴
}
heap{
    class 할당 후 연결
    1500
    name[0x44]              ->(참조)0x44["ssafy]                  
    age[0]                  
    address[0x99]           ->0x99["강남구"]

    100 length[0]

    hashtable{
        0x11 | 100
        0x73 | 1500 (여기까지가 new가 하는 역할)
    }
}
method{
    customer class[ (hashcode는 4바이트, class도 객체로 올라간다)
        Customer
        name : String
        age : int
        address : String

        CustomerInfo()
        ...

    ]

    class가 없을시 여기보고 로딩
    [0X93 | customer | 10000]
}

Encapsulation
속성 / 일부 method
은닉 => decouple => 수정성 증가
setter(set 속성이름)와 getter(get 속성이름)를 public한 method로 활용