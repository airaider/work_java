API

자기 패키지를 벗어난 곳에서는 외부 method를 활용하기 위해서는 full-name을 호출해야한다
bin>java chapter03.MethodTest
import 패키지명.클래스명;
import 패키지명.*(class만 import);  성능차이는 없다, 컴파일러가 다 알아서 바꿔줌
다른 패키지에 똑같은 클래스가 있으면 컴파일 오류가 뜬다
java.util.Date 처럼 직접적으로 어느 클래스의 패키지를 사용할지를 명시해야한다

아래 순서 안지키면 컴파일 오류 발생
package 선언
import 문
클래스 선언

javac -d path 소스파일


상속(Inheritance)
interface 상속 : Type
클래스 상속 : Type + 구현(속성, method)

- 모든 속성과 모든 메소드를 상속받음
- 단일 상속만 지원 (c는 다중 상속 : 하지만 무겁다)
- 생성자는 상속되지 않는다, 재사용을 위해서 호출은 가능
- 재사용(객체 생성(재사용만 가능), 상속(재사용+변경(속성 기능 추가, 수정가능)))

부모 클래스
상위 클래스(super)

자식 클래스
하위클래스(sub)

[modifiers]class sub클래스명[extends 부모클래스명]      클래스 객체가 생성될때 할당(동적할당)
 

Method Override(함수 재정의)
- 상속 박은 매서드와 동일한 이름의 함수를 선언할 수 있다.
- 목적
    상속 받은 매서드와 기능이 동일하지만 상세 구현이 조금 다른 경우
    반영하기 위해 새로운 매서드를 작성해야하는데 이때 매서드 이름과, 인자, 리턴타입을
    상속 받은 매서드와 동일하게 선언한다.
    
- 효과
1. 상속 받은 새거드와 이름, 인자가 같으므로 매서드 호출하는 방법이 같고
        리턴 타입이 같으므로 호출후 처리 방법이 같아지므로 기존 코드를 변경하지 않고
        수정된 내용을 반영할 수 있다.
2. 기능이 동일한 경우 부모 객체, 자식 객체 구별하지 않고 같은 이름으로 함수를 호출한다.
    => 호출에 대한 편리성
    
- 규칙
1. 매서드 이름과 인자는 반드시 같아야 한다.
2. 리턴 타입
    1.7 리턴 타입이 반드시 같아야 한다
    1.8 같은 타입이거나 sub를 리턴해야 됨
    ex) 부모 : public Customer getCustomer(){}
        자식 : public Customer getCustomer(){}
        or	 public MainCustomer getCustomer(){}	
3. access modifier는 같거나 보다 넓은 범위 (public)로 선언한다
    => access modifier를 줄이면 컴파일 오류 발생
4. 예외는 같은 예외를 던지거나 sub를 던지거나 안던져도 됨
    => super를 던지면 컴파일 오류 발생

super
    재정의에 의해 무시된 부모의 멤버(속성,함수)에 접근할 때 super를 상ㅇ
    super.함수명(~)	super.속성명

부모측에 기본생성자가 없으면 모든 자식생성자에서 컴파일 에러가 뜬다

stack{
    main{
        cust[]
    }
}
heap{
    class{  hasscode는 하나다(하나의 객체만 생성)
        hobby[null]

        name[null]
        age [0]
        address [null]
    }
    
}
method{
    [
    main Customer
    hobby : String
    customerinfo()
    ]
    [
        Customer
        name : String
        age : int
        address : String
        customerinfo();
    ]
}
자식 생성자에 부모 생성자가 호출되어야 할당이 가능하다
해결방법은 인자있는 생성자를 생성자의 첫번째에 명시적으로 호출해준다


Polymorphism(다형성)
method{
    인자에 따라서 method Overloading
    부모에 따라서 method Overriding
}호출에 대한 편리성 제공
Data{(형변환)
    Primitve    double로 다른 형 cover 가능, +boolean
    Reference   super type의 변수가 sub type의 객체를 참조할 수 있다.
}

Employee emp = new Employee();
emp = new Manager();
emp = new Engineer();

다형성의 그림자에 가려져서 못쓰는 것을 shadow impact라고 부른다
부모에서 선언한 값들만 활용가능 super type의 sub객체

정적 linking move
c,c++ : 컴파일
Java : 클래스 로딩할 때




Static
동적인 java를 정적으로 만들어줌